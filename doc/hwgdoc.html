<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <title>HwGUI documentation</title>
  <link rel="stylesheet" type="text/css" href="table.css">
</head>
<body bgcolor="#ffffff" text="#000000">

<table width="100%" border="0" cellpadding="0" cellspacing="0">
  <tr>
    <td width="15%" align="left"><a href="http://www.kresin.ru">Home page</a></td>
    <td width="70%" align="center"><strong class="title"> HwGUI 2.23 reference manual </strong></td>
    <td width="15%" align="right">&nbsp;</td>
  </tr>
  <tr>
    <td width="15%" align="left">&nbsp;</td>
    <td width="70%" align="center">Alexander S.Kresin, October 2023</td>
    <td width="15%" align="right"><a href="hwgdoc_commands.html">next</a></td>
  </tr>
</table>
<hr align="left" width="100%">

    <ul>
      <li><a name="_Introduction" href="#Introduction">1. Introduction</a>
      <ul>
         <li><a name="_Whatis" href="#Whatis">1.1.  What is HwGUI</a>
         <li><a name="_History" href="#History">1.2.  History of HwGUI</a>
         <li><a name="_Learn" href="#Learn">1.3.  How to learn HwGUI</a>
      </ul>
      <li><a name="_Install" href="#Install">2.  Installation of HwGUI</a>
      <ul>
         <li><a name="_Package" href="#Package">2.1.  HwGUI package</a>  
         <li><a name="_Instwin" href="#Instwin">2.2.  How to build HwGUI library (Windows version)</a>
         <li><a name="_Instlin" href="#Instlin">2.3.  How to build HwGUI library (GTK version)</a>
         <li><a name="_Instsamp" href="#Instsamp">2.4.  How to build HwGUI application</a>
      </ul>
      <li><a name="_Using" href="#Using">3.  How to use HwGUI</a>
      <ul>
         <li><a name="_Using1" href="#Using1">3.1.  Terminology</a>
         <li><a name="_Using2" href="#Using2">3.2.  Classes, commands and functions</a>
         <li><a name="_Using3" href="#Using3">3.3.  First HwGUI application</a>
         <li><a name="_Using4" href="#Using4">3.4.  Windows in HwGUI. Modal and nomodal.</a>
         <li><a name="_Using5" href="#Using5">3.5.  Controls review.</a>
         <li><a name="_Using6" href="#Using6">3.6.  General information about commands.</a>
         <li><a name="_Using7" href="#Using7">3.7.  General information about classes.</a>
         <li><a name="_Using8" href="#Using8">3.8.  GET-system</a>
         <li><a name="_Using9" href="#Using9">3.9.  Inside HwGUI</a>
         <li><a name="_Using10" href="#Using10">3.10.  Using the UNICODE</a>
         <li><a name="_Using11" href="#Using11">3.11.  Handling resources</a>
         <li><a name="_Using12" href="#Using11">3.12.  Multiplatform Instructions</a>         
      </ul>
      <li><a name="_Commands" href="hwgdoc_commands.html#Commands">4.  Commands</a>
      <ul>
        <li><a name="_Commands1" href="hwgdoc_commands.html#Commands1">4.1.  Commands for windows and dialogs handling</a>
        <li><a name="_Commands2" href="hwgdoc_commands.html#Commands2">4.2.  Menu commands</a>
        <li><a name="_Commands3" href="hwgdoc_commands.html#Commands3">4.3.  Commands for controls handling</a>
        <li><a name="_Commands4" href="hwgdoc_commands.html#Commands4">4.4.  Get system commands</a>
        <li><a name="_Commands5" href="hwgdoc_commands.html#Commands5">4.5.  Print commands</a>
      </ul>
      <li><a name="_Functions" href="hwgdoc_functions.html#Functions">5.  Functions</a>
      <ul>
        <li><a name="_Functions1" href="hwgdoc_functions.html#Functions1">5.1.  Common dialogs</a>
        <li><a name="_Functions2" href="hwgdoc_functions.html#Functions2">5.2.  MessageBoxes and HwGUI dialogs</a>
        <li><a name="_Functions3" href="hwgdoc_functions.html#Functions3">5.3.  Drawing functions.</a>
        <li><a name="_Functions4" href="hwgdoc_functions.html#Functions4">5.4.  Windows handling functions.</a>
        <li><a name="_Functions5" href="hwgdoc_functions.html#Functions5">5.5.  Controls handling functions.</a>
        <li><a name="_Functions6" href="hwgdoc_functions.html#Functions6">5.6.  Menu functions.</a>
        <li><a name="_Functions7" href="hwgdoc_functions.html#Functions7">5.7.  Windows registry.</a>
        <li><a name="_Functions8" href="hwgdoc_functions.html#Functions8">5.8.  Miscellaneous functions.</a>
        <li><a name="_FunctionsA" href="hwgdoc_func2.html#FunctionsA">5.A.  Functions, not included in documentation</a>
      </ul>
      <li><a name="_Classes" href="hwgdoc_classes.html#Classes">6.  Classes</a>
      <ul>
        <li><a name="_Classes1" href="hwgdoc_classes.html#Classes1">6.1.  Class hierarchy</a>
      </ul>
      <li><a name="_Util" href="hwgdoc_misc.html#Util">7.  Utilities</a>
      <ul>
        <li><a name="_Util1" href="hwgdoc_misc.html#Util1">7.1.  Designer</a>
        <li><a name="_Util2" href="hwgdoc_misc.html#Util2">7.2.  Tutorial</a>
        <li><a name="_Util3" href="hwgdoc_misc.html#Util3">7.3.  Visual debugger</a>
        <li><a name="_Util4" href="hwgdoc_misc.html#Util4">7.4.  Editor</a>
        <li><a name="_Util5" href="hwgdoc_misc.html#Util5">7.5.  Dbc</a>
        <li><a name="_Util6" href="hwgdoc_misc.html#Util6">7.6.  Binary container manager</a>
        <li><a name="_Util7" href="hwgdoc_misc.html#Util7">7.7.  Developer tools</a>
      </ul>
      <li><a name="_Contrib" href="hwgdoc_misc.html#Contrib">8.  Contrib</a>
      <ul>
        <li><a name="_Contrib1" href="hwgdoc_misc.html#Contrib1">8.1.  ActiveX</a>
        <li><a name="_Contrib2" href="hwgdoc_misc.html#Contrib2">8.2.  QHTM</a>
        <ul>
          <li><a name="_Qhtm1" href="hwgdoc_misc.html#Qhtm1">8.2.1.  Overview</a>
          <li><a name="_Qhtm2" href="hwgdoc_misc.html#Qhtm2">8.2.2.  Commands</a>
          <li><a name="_Qhtm3" href="hwgdoc_misc.html#Qhtm3">8.2.3.  Functions</a>
        </ul>
       <li><a name="_Contrib3" href="hwgdoc_misc.html#Contrib3">8.3.  Misc</a>
       <li><a name="_Contrib4" href="hwgdoc_misc.html#Contrib4">8.4.  Ext. Controls</a>
       <li><a name="_Contrib5" href="hwgdoc_misc.html#Contrib5">8.5.  hwmake</a>
       <li><a name="_Contrib6" href="hwgdoc_misc.html#Contrib6">8.6.  hwreport</a>
      </ul>
      <li><a name="_License" href="hwgdoc_misc.html#License">9.  License</a>
      <li><a name="_Author" href="hwgdoc_misc.html#Author">10.  About the author</a>
    </ul>

    <br><strong class="title"><a name="Introduction" href="#_Introduction">
     1.  Introduction</a></strong><br>

    <br><strong class="subhead"><a name="Whatis" href="#_Whatis"> 
     1.1.  What is HwGUI</a></strong><br>

    <p> HwGUI is an add-on library for <a href="http://www.Harbour-Project.org">Harbour</a>
     and <a href="http://www.xHarbour.org">xHarbour</a>, intended for creating GUI
     applications. There are two versions of HwGUI -  Win32 version, which is based on direct calls of Win32 API,
     and GTK version, which uses GTK2 library and can be used under any platform where GTK is implemented ( Linux,
     Windows, probably MacOS ).</p>

     <p>Most of GUI frameworks, not only for Harbour, but for other languages, too, which are ​​based
     on third-party libraries, use these libraries on all supported operating systems. That is, if any
     framework is based, say, on the <i>QT</i>, it uses <i>QT</i> for both Windows and Linux.
     HwGUI key feature is that Windows version uses the native WinAPI - no need to
     additional mega-ton dlls for every, even the simplest application; it works faster as
     there are no additional layers between your code and WinAPI. At the same time, for other operating systems,
     ( Linux - first of all), GTK engine is used. But the Harbour code remains the same.</p>

     <p>While developing HwGUI I tried to hide from the end user - Harbour programmer technical details of
     API calls and to build a set of commands and functions, which could allow
     easily create and manage GUI objects.</p>

    <br><strong class="subhead"><a name="History" href="#_History"> 
     1.2.  History of HwGUI</a></strong><br> 
     <p>I began to work on HwGUI in August 2001 and the first version was released
     on August 21.
     Of course, one of sources of inspiration for me was <a target="_blank" href="http://www.fivetechsoft.com/"> Fivewin of Antonio Linares</a> -
     the only at that time GUI library for Harbour.</p>

     <p>My initial intention was to create a small and fast GUI lib mainly
     for my own needs. And already in October I had wrote the first small application
     with HwGUI for my firm, it reads the databases, created and managed with the
     accounting system, generates some documents and sends them by fax.</p>

    <p> Firstly, from the initial release and til the 1.3 HwGUI didn't use the
     OOP paradigm - and I even had declared this as one of HwGUI features. My main
     motivations was speed and stability. Harbour's implementation of classes at
     that time had some bugs and I didn't want to add problems to myself. And,
     of course, access to object's variables is more slow than access to the array
     items. OOP is an additional level and using of it reduces application's
     performance.</p>
    <p> But later I have arrived at a decision to make HwGUI OOP based - to simplify
     user interface and make it better structured and more convenient. So starting from
     the release 2.0 HwGUI is based on OOP paradigm.</p>
    <p> Since the autumn'2003 HwGUI is <a href="http://sourceforge.net/projects/hwgui/">hosted by SourceForge</a>,
     and there is a group of developers working on it. Thanks to all of them for participation
     and contributions.</p>
    <p> Yet another important milestone in HwGUI's timeline is a December,2005 - where
     a development of GTK version has been started, so HwGUI became a cross-platform
     tool.</p>

    <br><strong class="subhead"><a name="Learn" href="#_Learn"> 
    1.3.  How to learn HwGUI</a></strong><br> 

    <p>First of all, of course, it is necessary to read this manual - at least the first 3 sections.
    Meanwhile, you can skip subsections <i>Inside HwGUI</i> and <i>Using the UNICODE</i>.
    For further study, I strongly recommend utility the <i>Tutorial</i> utility, located in <code>hwgui/utils/tutorial/</code>.
    This utility contains an ordered set of code samples on HwGUI with comments, all of which can be
    executed directly from the utility. Moreover, the code placed in a built-in editor with syntax highliting,
    you can edit it and execute immediately, that is, it is the fastest way to check
    the work of certain HwGUI constructions, styles, etc.
    Compile samples from <code>hwgui/samples/</code>, utilities from <code>hwgui/utils/</code>,
    review their code. And, of course, write yourself, write a little more - it is the best way to learn something.
    Good luck!</p>
     
    <br><strong class="title"><a name="Install" href="#_Install">
     2.  Installation of HwGUI</a></strong><br>

    <p>
     Look into file "install.txt" for extra installation instructions (Prerequisite packages for LINUX,
      optional cross development environment for GTK on Windows).
    </p>
    <br><strong class="subhead"><a name="Package" href="#_Package">

    2.1.  HwGUI package</a></strong><br>

    <p>HwGUI is distributed as an archive, zip for Windows and tar.gz, tar.bz2 - for Linux. Currently it doesn't use any setup
     utility, you need simply unpack it to any place you want. The archive package
     includes following files and directories:</p>

     <pre class="code">
     Changelog
     *.hbp,*.hbc      - build files for Hbmk
     make_b32.bat     - command files to build HwGUI libraries, using Borland C
     makefile.bc
     make_vc.bat      - command files to build HwGUI libraries, using MSVC
     makefile.vc
     make_pc.bat      - command files to build HwGUI libraries, using Pelles C
     makefile.pc
     make_w32.bat     - command files to build HwGUI libraries, using Open Watcom C
     makefile.wc
     makemngw.bat     - command files to build HwGUI libraries, using Mingw
     makefile.gcc
     makedll.bat      - command files to build HwGUI dll, using Borland C
     makedll.bc
     license.txt
     install.txt      - installation notes
     whatsnew.txt
     contrib\         - a directory with contribution modules, which for
                        various reasons were not included in the basic sources set
     
         activex\     - sources of HActiveX И HHtml classes - implementation of ActiveX
                        technology
         ext_controls\- few additional controls classes
         hwmake\
         misc\
         qhtm\        - sources of HQhtm class
     doc\             - directory with documentation
     image\           - directory with sample image files
     include\         - directory with  HwGUI headers files
     lib\             - directory with HwGUI libraries
     samples\         - directory with HwGUI samples
         gtk_samples\ - directory with samples for GTK version
     source\          - Hwgui sources
         common\      - common sources for both versions
             debug\   - sources of hwgdebug library
             editor\  - sources of Hilight и HcEdit classes - an editor with syntax
                        highliting
             procmisc\- set of functions
             xml\     - sources of HXMLDoc, HXMLNode classes - reading and writing of
                        xml files
         gtk\         - GTK version sources
         winapi\      - WinAPI version sources
     utils\           - directory with utilities
         bincnt\      - Binary container manages
         dbc\         - Data Base Control
         debugger\    - GUI debugger for Harbour
         designer\    - The Designer, an utility to create screen forms and reports
         editor\      - A text editor with extended formatting possibilities
         tutorial\    - Interactive HwGUI tutorial.
         devtools     - Developer tools
     </pre>

     <p>In binary distributions, build files and sources are absent.
     in the source distribution, the <code>lib/<code> directory is absent - it will be created during the build process.</p>

    <br><strong class="subhead"><a name="Instwin" href="#_Instwin">
    2.2.  How to build HwGUI library (Windows version)</a></strong><br>

    <p>For a binary distribution this issue isn't actual, of course. So, we are talking here about
    the source distribution. Compiling HwGUI is quite simple - as compiling of any Harbour program.</p>

    <p>Harbour programmers may use Hbmk2 (previous Hbmk) utility (it is absent in xHarbour). Just run it with hbp files:</p>
    <pre class="code">
       hbmk2 hwgui.hbp hbxml.hbp hwgdebug.hbp procmisc.hbp
    </pre>

    <p>As a result, ypu will get hwgui, hbxml, hwgdebug and procmisc libraries in your <code>hwgui/lib/</code> directory.</p>

    <p>You may use also one of command files, included in distribution, depending of your C compiler.
    For xHarbour programmers it is the only way. I prefer it, too, simply because I like to keep
    control ob the building process.</p>

    <p>Before building the libraries you need to set the HB_PATH environment
    variable, it should point to the directory where your copy of Harbour or xHarbour is.
    You may set it on your Windows environment or in the appropriate command ( .bat ) file,
    including there a line:
    <pre class="code">
       SET HB_PATH=c:\harbour
    </pre>

    Then run one of command files depending of the C compiler you use 
    ( make_b32.bat for Borland C, make_pc.bat for Pelles C, make_vc.bat for MSVC,
    make_w32.bat for Open Watcom C, makemngw.bat for Mingw ) - this will build four libraries -
    hwgui.lib, procmisc.lib, hwg_qhtm.lib and hbxml.lib. That's all !</p>

    <br><strong class="subhead"><a name="Instlin" href="#_Instlin">
    2.3.  How to build HwGUI library (GTK version)</a></strong><br>

    <p>The sources of GTK version are located in <code>hwgui/source/gtk/</code> directory.
    In the same place ypu will find a bash script for libraries building  - <code>build.sh</code>.
    Before to launch it, you need to check the Harbour installation. If it was installed
    using binary deb or rpm package, Harbour files most likely are placed in
    <code>/usr/local/bin</code>, <code>/usr/local/include/harbour</code>, <code>/usr/local/lib/harbour</code>.
    In this case you don't need to do any additional work. But if your Harbour is placed
    in separate directory, compiled from sources, you need to set the path to this directory
    in HB_ROOT environment variable. You may insert appropriate line in <code>build.sh</code>, for example:</p>
    <pre class="code">
       export HB_ROOT=../../..
    </pre>

    <p>Now you can run the <code>build.sh</code> and the ready libraries must appear in
    <code>hwgui/lib/</code> directory.</p>

    <br><strong class="subhead"><a name="Instsamp" href="#_Instsamp">
    2.4.  How to build HwGUI application</a></strong><br> 

    <p>Now let talk about compiling and linking GUI programs with Harbour. HwGUI provides
    few header files in <code>include/</code> and four libraries:</p>
    <ul>
       <li>hwgui     - main HwGUI library;
       <li>hwgdebug  - visual debugger library, need to be linked together with hbdebug for program debugging;
       <li>hbxml     - a library of classes for reading/writing xml files, it is necessary to use forms and reports, created with the Designer;
       <li>procmisc  - a set of additional functions and HcEdit class.
    </ul>

    <p> Hwgdebug, hbxml and procmisc may be used without HwGUI, too.
    Besides, there are 3 additional library from <code>contrib/</code>, which may be linked, if needed:</p>
    <ul>
       <li>hbactivex   - a library of classes for ActiveX support;
       <li>hwg_extctrl - few additional controls, extending appropriate standard controls;
       <li>hwg_qhtm    - bindings to qhtm, a simple 3-rd party library for html rendering.
    </ul>

    <p>To build the GUI program, you need to link necessary libraries and add some options
       for the C linker - these options are different for different C systems.
       For to not write all these manually, HwGUI distribution includes scripts that solve this task.
       For those, who use Hbmk, there is <code>hwgui/hwgui.hbc</code>. Following is a command line
       to build some <code>myprog.prg</code>, if your <code>hwgui\</code> directory is located in <code>c:\harbour\</code>:</p>
    <pre class="code">
      hbmk2 c:\harbour\hwgui\hwgui.hbc myprog.prg
    </pre>
    For WinAPI version I recommend always add a file <code>samples\hwgui_xp.rc</code>, for Windows themes was used:
    <pre class="code">
      hbmk2 c:\harbour\hwgui\hwgui.hbc hwgui_xp.rc myprog.prg
    </pre>

    <p>For those, who don't use Hbmk, there are command files in <code>samples\</code> directory for different C compilers.
    You may use them to build sample programs from <code>samples\</code> or as a templates to build your programs.</p>

    <p>For GTK version you may use Hbmk or <code>samples/gtk_samples/build.sh</code> bash script - probably,
    you will need to set the HB_ROOT environment variable, as described in a subsection <a href="#Instlin">2.3. How to build HwGUI library (GTK version)</a>.</p>

    <br><strong class="title"><a name="Using" href="#_Using">
    3.  How to use HwGUI</a></strong><br>

    <br><strong class="subhead"><a name="Using1" href="#_Using1">
    3.1.  Terminology</a></strong><br><br>
    <p></p>

    <br><strong class="subhead"><a name="Using2" href="#_Using2">
    3.2.  Classes, commands and functions</a></strong><br><br>
    <p></p>

    <br><strong class="subhead"><a name="Using3" href="#_Using3">
    3.3.  First HwGUI application</a></strong><br><br>

    <pre class="code">
       #include "hwgui.ch"

       Function Main
       Local oMainWnd, oFont
       Local aCombo := {"First","Second" }

          PREPARE FONT oFont NAME "MS Sans Serif" WIDTH 0 HEIGHT -13

          INIT WINDOW oMainWnd TITLE "Example" ;
             FONT oFont ;
             ON EXIT {||hwg_MsgYesNo("Really want to quit ?")}

          @ 20,10 EDITBOX "Hello, World!" SIZE 200,30

          @ 270,10 COMBOBOX aCombo SIZE 100, 150 TOOLTIP "Combobox"

          @ 120,60 BUTTON "Close" SIZE 150,30 ;
             ON CLICK {||oMainWnd:Close()}

          MENU OF oMainWnd
             MENUITEM "About" ACTION hwg_MsgInfo("First HwGUI Application")
          ENDMENU

          ACTIVATE WINDOW oMainWnd

          hwg_writelog( "Program terminated " + Dtoc(Date()) + " at " + Time() )

      Return
    </pre>

    <p>First thing you will want to do, I think, is to create the main window.
    The best way to do this is the command <a href="#Commands1-1">INIT WINDOW</a>. In
     this command you can define initial position and the size of the window, it's
     style, icon, background color. You can set also event handlers - codeblocks, which
     are evaluated for different events ( INIT, EXIT, PAINT, SIZE changing, GETFOCUS, LOSTFOCUS and
     others ).</p>

    <p>Then you need to <a href="#Commands3">define controls</a> for that window and
     the main menu ( <a href="#Commands2">MENU ... ENDMENU</a> commands), and, at least,
     activate the window, ( <a href="#Commands1-3">ACTIVATE WINDOW</a> ) show it on the screen.
     Let analyse the above sample.</p>

    <pre class="code">
      PREPARE FONT oFont NAME "MS Sans Serif" WIDTH 0 HEIGHT -13</pre>

    <p>At first, we create the font object for the main window. HwGUI works in such a way,
      that if a font isn't defined for a control, this control uses the font, defined
      for his parent window.</p>

    <pre class="code">
      INIT WINDOW oMainWnd MAIN TITLE "Example" ;
         FONT oFont ;
         ON EXIT {||hwg_MsgYesNo("Really want to quit ?")}</pre>

    <p>This command creates main window with the title "Example" and with previously created font.
      ON EXIT clause will cause  appearance of a message box, user will need to choose "Yes" to quit the application.</p>

    <pre class="code">
      @ 20,10 EDITBOX "Hello, World!" ;
         SIZE 200,30
      @ 270,10 COMBOBOX aCombo ;
         SIZE 100, 150 TOOLTIP "Combobox"
      @ 120,60 BUTTON "Close" ;
         SIZE 150,30 ;
         ON CLICK {||hwg_EndWindow()}</pre>

    <p>The above commands creates appropriate controls - Edit, Combobox and Push Button.
      ComboBox is initialized with aCombo array, which was declared before. Button has
      an event handler defined - closing the application.</p>

    <pre class="code">
      MENU OF oMainWnd
         MENUITEM "About" ACTION hwg_MsgInfo("First HwGUI Application")
      ENDMENU</pre>

    <p>These commands creates the main menu, which includes the only item "About".</p>

    <pre class="code">
      ACTIVATE WINDOW oMainWnd</pre>

    <p>And, at least, this last command activates the main window. It appears on
       the screen with menu and all controls defined. Pay attention to the important fact: the
       main window is modal, i.e., when it appears on the screen the program stops.
       This means, that the lines of the code, which are located after <code>ACTIVATE WINDOW oMainWnd</code>,
       will be executed only after the window closes. In our sample this is a line, which
       writes date and time to a log:</p>

    <pre class="code">
      hwg_writelog( "Program terminated " + Dtoc(Date()) + " at " + Time() )</pre>

    <p>You can see that it is added to the file not immediately after the appearance of the window,
     but only after it is closed. These explanations may seem trivial for you,
     but many programmers just starting to write GUI applications, have some difficulties with this behaviour.</p>

    <br><strong class="subhead"><a name="Using4" href="#_Using4">
    3.4.  Windows in HwGUI. Modal and nomodal.</a></strong><br><br>
    <p></p>

    <br><strong class="subhead"><a name="Using5" href="#_Using5">
    3.5.  Controls review.</a></strong><br><br>
    <p></p>

    <br><strong class="subhead"><a name="Using6" href="#_Using6">
    3.6.  General information about commands.</a></strong><br><br>
    <p></p>

    <br><strong class="subhead"><a name="Using7" href="#_Using7">
    3.7.  General information about classes.</a></strong><br><br>
    <p></p>

    <br><strong class="subhead"><a name="Using8" href="#_Using8">
    3.8.  GET-system</a></strong><br><br>
    <p></p>

    <br><strong class="subhead"><a name="Using9" href="#_Using9">
    3.9.  Inside HwGUI</a></strong><br><br>

    <p>From the point of messages handling all HwGUI windows ( and controls,
    which, in fact, are windows, too ) may be divided in two groups:
    <blockquote>
    1) The windows, which messages are handled by HwGUI.<br>
    2) The windows, which messages are handled by Windows API only.
    </blockquote>
    The first group includes main, mdi, child windows and dialogs and such
    controls as ( I will use the appropriate classes names ) HBrowse,
    HEdit, HStaticLink, HOwnButton, HPanel, HRichEdit, HSplitter, HTab,
    HTrackBar.<br>
    The second - all other controls, such as HStatic, HStatus, HButton,
    HGroup, HCheckButton, etc.</p>
    <p>Handling of messages for the first group is implemented in the
    following way:<br>
    Window ( control ) creation functions stores the pointer to the
    appropriate HwGUI object in a window extra memory, granted by Windows
    API - by calling the function SetWindowObject().
    Besides, the window creation functions sets the pointer to the window
    procedure ( an application-defined function that processes messages
    sent to a window ). This is implemented by setting the pointer in
    WNDCLASS structure ( see, for example, HWG_INITMAINWINDOW(),
    HWG_REGBROWSE() ) or by redefinition the window procedure (
    HWG_INITEDITPROC(), HWG_INITWINCTRL() ).<br>
    Thus, all windows of a first group has special messages processing
    procedures ( MainWndProc(), WinCtrlProc(), ... ), while messages for
    windows of a second groups are processed by Windows API internally.
    The messages processing procedure extracts the pointer to appropriate
    HwGUI object from a window extra memory and calls the :onEvent method
    for this object.<br>
    The :onEvent method may process the message itself, or pass it to the
    super method, or, returning -1, pass it to the default Windows API
    procedure.</p>
    <p> For example, the HStatic and HStatus are a second
     group controls, i.e. messages to this control aren't processed by HwGUI -
     that's why Windows doesn't process notifications, messages for it
     child controls.<br>
     So, if you want to create ontop of them other controls, they are two ways:
    <blockquote>
     1) create a new class, derived from HStatic and make it a control of
     a first group ( store a object pointer and redefine the window
     procedure )<br>
     2) use as a place holder for a button not HStatic or HStatus, but,
     for example, the HPanel. Hpanel is a general purpose control, which
     I use and recommend you to use for such purposes.
    </blockquote>
    </p>

    <br><strong class="subhead"><a name="Using10" href="#_Using10">
    3.10.  Using the Unicode</a></strong><br><br>
    <p></p>

    <br><strong class="subhead"><a name="Using11" href="#_Using11">
    3.11.  Handling resources</a></strong><br><br>

    <p>
    Resources in GUI applications means:<br>
    <blockquote>
    1.) Icons and images<br>
    2.) Forms<br>
    3.) Iconification
    </blockquote>
    Most development tools for GUI programs (like Micosoft Visual C/C++)
    contain a tool for handling and designing resources.<br>
    You can desingn forms adding typical windows elements for display
    (text, images, icons), control's (button's, radio buttons, ...) or
    for editing.<br>
    The designed resources are stored in a resource file, in most cases
    with file ending ".rc" and were compiled into the exe file.<br>
    This feature is supported by HWGUI, but the resource files are not
    compatible between the various development tools.<br><br>
    For multi platform purposes here the description of the strategy with HWGUI:<br><br>
    To design forms use the HWGUI utility "HWGUI Designer".<br>
    The design is stored in an XML file. It can be read at run time (look at source of utils and samples)
     or the form can also stored as HWGUI source file (*.prg).<br>
    Copy the generated code into the source code of your application.<br>
    But because of bugs in this function corrections of the generated code is needed.<br>
    Known bugs:<br>
    <blockquote>
    - Check the generated list of object variables of control elements in the LOCAL declaration section.
      Add missing variables.<br>
    - If a form contains a checkbox definition, the HWGUI designer crashes at storing of prg file.<br>
      &nbsp;&nbsp;The workaround is, to store the checkbox as a static text, starting with "X".<br>
      &nbsp;&nbsp;Modfiy the command , but the position and size can be copied.<br>
    - The designer runs at this time only correct on Windows. We will finish the port to<br>
      &nbsp;&nbsp;LINUX as soon as possible.<br>
    </blockquote>
    <br>
    For details read the chapter <a name="_Util1" href="hwgdoc_misc.html#Util1">7.1.  Designer</a><br>
    <br>
    A good editor for icons is "Greenfish Icon Editor Pro" (free and open source).
    <br><br>
    </p>
    <p>
    <b>Iconification</b><br><br>
      &nbsp;On Windows:
      <br>
      &nbsp;If you will see the program icons in links on the deskop:<br>
      &nbsp;<img src="./image/CLLOG_Link.png" align=center wborder=0 alt="Link to CLLOG on Windows desktop"><br>
      &nbsp;or compiled in the exe file:<br>
      &nbsp;(properties of the exe file, right mouse click ==> Properties)<br>
      &nbsp;<img src="./image/Win_CLLOG_exeProperties.png" align=center wborder=0 alt="CLLOG properties of exe file"><br>
      <br>
      &nbsp;you must use the resource compiler<br>
      &nbsp;(is delivered with the most compilers for Windows like Borland C and MinGW).<br>
      <br> 
      <br>
      &nbsp;Otherwise a default icon is showed:<br>
      &nbsp;<img src="./image/Win_bincnts_Link.png" align=center wborder=0 alt="Link to bincnts.exe on Windows desktop"><br>
      &nbsp;(Verkn&uuml;pfung ==> link)
      <br>
      <br>
      &nbsp;You need a resource file only with 2 lines (for example):<br>
      <br>
      &nbsp;cllog.rc:<br>
      &nbsp;&nbsp;1 24 "./images/WindowsXP.Manifest"<br> 
      <br>
      &nbsp;&nbsp;CLLOG&nbsp;&nbsp;ICON&nbsp;resource\cllog.ico<br>
      <br>
      &nbsp;Attention !<br>
      &nbsp;A file name and path like "..\image\cllog.ico"<br>
      &nbsp;causes a syntax error at resource compiling.<br> 
      <br>
      &nbsp;You find the file WindowsXP.Manifest in directory "\image".<br>
      <br>
      &nbsp;The icon was compiled into the exe file, that the operating can find the icon:<br>
      <br>
      &nbsp;hbmk2 %PRGNAME%.prg cllog.rc ...<br>
      <br>
      &nbsp;In your main program, add the icon following this example:<br>
      <br>
      &nbsp;#ifndef __GTK__<br>
      &nbsp;&nbsp;&nbsp;oIcon1 := HIcon():AddResource( "CLLOG" )<br>
      &nbsp;#else<br>
      &nbsp;&nbsp;&nbsp;oIcon1 := HIcon():AddString( "cllog" , cResourceCLICO  ) && loaded from hex values<br>
      &nbsp;#endif<br>
      &nbsp;...<br>
      &nbsp;&nbsp;INIT WINDOW oWndMain TITLE "Title"  ;<br>
      &nbsp;&nbsp;AT nx,ny SIZE nheight,nwidth ;<br>
      &nbsp;&nbsp;ICON oIcon1<br>
      &nbsp;...<br>
      <br>
      &nbsp;In the INIT WINDOW command the icon was only showed at run time !<br>
      <br><br>
      <br>&nbsp;On LINUX:<br>
      &nbsp;The Icon was displayed at runtime in the tray bar and the header Window:<br>
      &nbsp;<img src="./image/CLLOG_LINUX_trayIcon.png" align=center wborder=0 alt="CLLOG tray icon on LINUX"><br>
      <br>
      <br>
      Special troubleshooting:<br>
      As reported with support ticket #55 some trouble<br>
      with program crashes caused by recource configuration<br>
      on MingW64 with GGC version >= 11, Windows 10.<br>
      <br>
      We suggest to add extra .rc files and compile scripts for<br>
      newer GCC versions.<br>
      If the following message appears:<br>
      &nbsp;<img src="./image/Msyscrash.png" align=center wborder=0 alt="Start error 0xc000007b"><br> 
      <br>   
      Die Anwendung konnte nicht korrekt gestartet werden.<br>
     (0xc000007b).<br>
      ==> The german text means:<br>
     The application could not be startet correctly.<br>
     To fix:<br>
     - Remove the line from all *.rc<br>
     1 24 "../image/WindowsXP.Manifest"<br>
     and change concerning the following sample:<br>
     CREATEPROCESS_MANIFEST_RESOURCE_ID RT_MANIFEST "../image/Windows64.Manifest"<br>
     <br>
     CLLOG           ICON   resource/cllog.ico
     <br>
     Change in the manifest file the entry<br>
     processorArchitecture="x86" to "ia64"<br>
     <br>
     - Load icons from file in the *.rc file, for example:<br>
     HWGUI  ICON image\hwgui_32x32.ico<br>
     All other resources can be loaded from hex hex values or<br> 
     the binary container.<br> 
     <br>
     </p>

      <br><strong class="subhead"><a name="Using12" href="#_Using12">
      3.12.  Multiplatform Instructions</a></strong><br><br>
      <p>
      In this chapter you find some description and tips for multi platform applications,<br>
      at this time especially for Windows and GTK/LINUX.<br>
      <br>
      <br>
      <b>Design rules</b><br>
      The designs of forms differs between Windows and GTK, in most cases
      the GUI elements needs more space.<br>
      <br>
      It is recommended to check the design for multi platform applications also on LINUX !<br>
      The sample program "samples/hello.prg" demonstrates the design differences.<br>
      Full infomation in the inline comments of this sample.<br>
      The compiler switch "#ifdef __GTK__" is used to select the commands for correct design.<br>
      Here some sceen shots for this example:<br>
      <br>
      Windows:<br>
      <img src="./image/Hello_main_Win.png" align=center wborder=0 alt="hello.prg main on Windows"><br>
      On LINUX with old design for Windows:<br>
      <img src="./image/Hello_GTK_main.png" align=center wborder=0 alt=
      "hello.prg main on LINUX with old Windows design"><br>
      On LINUX with new design:<br>     
      <img src="./image/hello_GTK_new.png" align=center wborder=0 alt="hello.prg main on GTK/LINUX"><br>
      <br>
      <br> 
      Some other instructions:<br>
      - Height 32 (default value in designer) for buttons is OK for Windows and GTK<br>
      - GTK: Main menu items need submenus.<br>
        For details look into "hwgdoc_commands.html", chapter "4.2. Menu commands",<br>
        item "Additional instructions for menus".  
           
      <br>
      <br>    
             
    </p>


<!-- Footer -->

<hr align="left" width="100%">
<table width="100%" border="0" cellpadding="0" cellspacing="0">
  <tr>
    <td width="33%" align="left">&nbsp;</td>
    <td width="34%" align="center"><a href="hwgdoc.html">table of contents</a></td>
    <td width="33%" align="right"><a href="hwgdoc_commands.html">next</a></td>
  </tr>
  <tr>
    <td width="33%" align="left">&nbsp;</td>
    <td width="34%" align="center">&nbsp;</td>
    <td width="33%" align="right">commands</td>
  </tr>
</table>

</body>
</html>
